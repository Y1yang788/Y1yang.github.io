[{"title":"AES","url":"/2025/01/16/AES/","content":"111测试\n"},{"title":"LFSR","url":"/2025/01/05/LFSR/","content":"LFSR概念了解LFSR是指线性反馈移位寄存器，给定一定的输出，将该输出的线性代数再用作输入的移位寄存器，异或运算是最常见的单比特线性代数：对寄存器的某些位进行异或操作后作为输入,再对寄存器中的各比特进行整体移位.该结构具有结构简单,运行速度快的特点,常被应用于伪随机数和伪随机噪声的生成中.同时,该原件常与流密码相关部分联合使用.\n原理LFSR是FSR的一种，还有一种是NFSR(非线性)函数可表示为:\n\n这里给不了解布尔运算的做一个基础补充：布尔运算分为与运算，或运算，异或运算和非运算\n与运算：\n或运算\n异或运算\n非运算\n\n\nan+1&#x3D;c1an⊕c2an-1⊕…⊕cna1\nan+2&#x3D;c1an+1⊕c2an⊕…⊕cna2\n…\nan+i&#x3D;c1an+i-1⊕c2an+i-2⊕…⊕cnai(i&#x3D;1,2,3…)\n\n例如:题型:1.已知反馈函数，输出序列，求逆推出初始状态\nfrom flag import flagassert flag.startswith(&quot;flag&#123;&quot;)assert flag.endswith(&quot;&#125;&quot;)# 作用：判断字符串是否以指定字符 开头或结尾assert len(flag)==25def lfsr(R,mask):    output = (R &lt;&lt; 1) &amp; 0xffffff #将R向左移动1位，bin(0xffffff)=&#x27;0b111111111111111111111111&#x27;    i=(R&amp;mask)&amp;0xffffff          #按位与运算符&amp;：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0    lastbit=0    while i!=0:        lastbit^=(i&amp;1)           #按位异或运算，得到输出序列        i=i&gt;&gt;1    output^=lastbit              #将输出值写入 output的后面    return (output,lastbit)R=int(flag[5:-1],2)  #flag为二进制数据mask    =   0b1010011000100011100f=open(&quot;key&quot;,&quot;ab&quot;)   #以二进制追加模式打开for i in range(12):    tmp=0    for j in range(8):        (R,out)=lfsr(R,mask)        tmp=(tmp &lt;&lt; 1)^out    f.write(chr(tmp))   #将lfsr输出的序列每8个二进制为一组，转化为字符，共12组f.close()\n思路:第一种方法:\nfrom Crypto.Util.number import*f = open(&#x27;key.txt&#x27;,&#x27;rb&#x27;).read()r = bytes_to_long(f)bin_out = bin(r)[2:].zfill(12*8)R = bin_out[:19]    #获取输出序列中与掩码msk长度相同的值print(R)mask = &#x27;1010011000100011100&#x27;  #顺序 c_n,c_n-1,。。。,c_1key =  &#x27;0101010100111000111&#x27;R = &#x27;&#x27;for i in range(19):    output = &#x27;x&#x27;+key[:18]    out = int(key[-1])^int(output[-3])^int(output[-4])^int(output[-5])^int(output[-9])^int(output[-13])^int(output[-14])^int(output[-17])    R += str(out)    key = str(out)+key[:18]print(&#x27;flag&#123;&#x27;+R[::-1]+&#x27;&#125;&#x27;)\n第二种方法：猜seed\nfrom Crypto.Util.number import*import os,sysos.chdir(sys.path[0])f = open(&#x27;key.txt&#x27;,&#x27;rb&#x27;).read()c = bytes_to_long(f)bin_out = bin(c)[2:].zfill(12*8)   #将key文本内容转换为 2 进制数，每个字节占 8 位R = bin_out[0:19]  #取输出序列的前19位mask = 0b1010011000100011100def lfsr(R,mask):    output = (R &lt;&lt; 1) &amp; 0xffffffff    i=(R&amp;mask)&amp;0xffffffff    lastbit=0    while i!=0:        lastbit^=(i&amp;1)        i=i&gt;&gt;1    output^=lastbit    return (output,lastbit)#根据生成规则，初始状态最后一位拼接输出序列#我们可以猜测seed的第19位（0或1），如果seed19+R[:18]输出值等于R[:19]，那么就可以确定seed值了def decry():    cur = bin_out[0:19]      #前19位 2 进制数    res = &#x27;&#x27;    for i in range(19):        if lfsr(int(&#x27;0&#x27;+cur[0:18],2),mask)[0] == int(cur,2):            res += &#x27;0&#x27;            cur = &#x27;0&#x27;+cur[0:18]        else:            res += &#x27;1&#x27;            cur = &#x27;1&#x27; + cur[0:18]    return int(res[::-1],2)r = decry()print(bin(r))\n第三种方法:\nimport os,sysos.chdir(sys.path[0])from Crypto.Util.number import *key = &#x27;0101010100111000111&#x27;mask = 0b1010011000100011100R = &quot;&quot;index = 0key = key[18] + key[:19]while index &lt; 19:    tmp = 0    for i in range(19):        if mask &gt;&gt; i &amp; 1:            tmp ^= int(key[18 - i])    R += str(tmp)    index += 1    key = key[18] + str(tmp) + key[1:18]print (R[::-1])\n"},{"title":"Hello World","url":"/2025/01/04/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"}]